gnu assembler directives
http://linux.web.cern.ch/linux/scientific4/docs/rhel-as-en-4/tic54x-directives.html
https://en.m.wikibooks.org/wiki/X86_Disassembly


  ...free... | loc3 | loc2 | loc1 | ebp^ | r.a. | arg1 | arg2 | arg3 | ...
             esp    -8     -4     ebp           +8     +12    +16

  push arg3
  push arg2
  push arg1
  call fn

    push ebp
    mov ebp,esp
    sub esp,12    ; for 3 local vars
    push edi
    push esi      ; save regs if used inside

    ...           ; locals [ebp-4 8 12 etc], args [ebp+8 12 16 etc]

    pop esi       ; restore regs if saved
    pop edi
    move esp,ebp
    pop ebp       ; leave
    ret           ;

  add esp,12


strings:

# char a[] = "a123\\a\"a\'a  \r11\n22\b33\0aa";

  .globl  _a
  .data
  .align 4
_a:
  .ascii "a123\\a\"a'a  \15"
  .ascii "11\12"
  .ascii "22\10"
  .ascii "33\0aa\0"   # but we won't do \0 inside

  .section .rdata,"dr"
LC0:
  .ascii "%d \0"


labels:

Sxx:  string literal
Exx:  else part of if-else
Ixx:  end of if-else
Lxx:  loop start (condition) \ Stack inside
Kxx:  loop end               / function
Rxx:  return from function
Axx:  for &&
Oxx:  for ||


char c            movsx eax, BYTE PTR [esp+15]

c = ...           mov BYTE PTR [esp+15], al

-a  ~a            neg eax    not eax

!a                cmp DWORD PTR [esp+4], 0
                  sete al
                  movzx eax, al

a + b             add eax, edx     sub    and   or

a * b             imul eax, DWORD PTR [esp+4]  ; eax

a / b             cdq
                  idiv DWORD PTR [esp+4]       ; eax

a % b             cdq
                  idiv DWORD PTR [esp+4]       ; edx

