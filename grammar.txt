// syntax: http://www.lysator.liu.se/c/ANSI-C-grammar-y.html
// {...} can be 0 or more times;  [...] is optional;  x|y alternative

primary : @Number | @Char | @String | @Id | '(' expr ')'

integer : @Number | @Char | @Id  // enum id is like number; maybe { binop integer }

exprs : expr { ',' expr } // args in calls and the last item in for-header

call_or_index : { '[' expr ']' | '(' [ exprs ] ')' }

postfix : primary call_or_index          // no: postfix ++|--

unexpr : '+''+' unexpr | '-''-' unexpr
       | '-' term | '!' term | '*' term  // no: &x ~x
       | postfix

type : "int" | "char" | "void" // void is used only for function result

stars : [ '*' [ '*' ] ]

term : '(' type stars ')' term
     | '(' expr ')' call_or_index        // shortcut, since we know it's '('
     | unexpr

binop : '*' | '/' | '%'                  // pri. 3     no:
      | '+' | '-'                        // pri. 4     5: << >>
      | '<' | '>' | '<''=' | '>''='      // pri. 6
      | '=''=' | '!''='                  // pri. 7     8 9 10: & ^ |
      | '&''&'                           // pri. 11
      | '|''|'                           // pri. 12    13: ?:
      | '='                              // pri. 14    14: += -= <<= ...

expr : term { binop term }

vardef_or_expr : type stars @Id vars     // ends with ';'
               | expr ';'

stmt : ';'
     | '{' block
     | "break" ';'                | "return" [ expr ] ';'
     | "while" '(' expr ')' stmt  | "if" '(' expr ')' stmt [ "else" stmt ]
     | "for" '(' vardef_or_expr [ expr ] ';' [ expr { ',' expr } ] ')' stmt
     | vardef_or_expr // ends with ';'

block : { stmt } '}'  // '{' is out of block for easier analysis

arrayinit : @String                           // char a[] = "abc"; // ARRAY!
          | '{' @String { ',' @String } '}'   // char* b[] = {"ijk","mn"};
          | '{' integer { ',' integer } '}'   // int c[] = {1,2,3};

vartail : [ '=' expr ]
        | '[' ']' '=' arrayinit               // int** c[] = {0,0};
        | '[' integer ']' [ '=' arrayinit ]   // int d[100] = {0};

vars : vartail { ',' stars @Id vartail } ';'

argdef : type stars @Id                  // e.g. char** argv

args : argdef { ',' argdef }

fn_or_vars : '(' [ args ] ')' ';'        // fn declaration
           | '(' [ args ] ')' '{' block  // fn definition
           | vars

enumerator : @Id [ '=' integer ]

enumdef : '{' enumerator { ',' enumerator } '}' ';'

decl_or_def : "enum" enumdef | type stars @Id fn_or_vars

program : decl_or_def { decl_or_def } @Eof  // definition/declaration


# vim: set syntax=ANTLR :
