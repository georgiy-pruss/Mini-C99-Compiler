// syntax: http://www.lysator.liu.se/c/ANSI-C-grammar-y.html
// {...} can be 0 or more times;  [...] is optional;  x|y alternative

// comments are inline and multi-line C comments /*...*/ and end-of-line
// C++ comments //... Also #... is treated as a comment, to ignore #include etc

primary : @Number | @Char | @String | @Id | '(' expr ')'

integer : [ '-' ] ( @Number | @Char | @Id ) // enum id is like a number

exprs : expr { ',' expr } // args in calls and the last item in for-header

call_or_index : { '[' expr ']' | '(' [ exprs ] ')' }

postfix : primary call_or_index          // no: postfix ++|--

unexpr : '+''+' unexpr | '-''-' unexpr
       | '-' term | '~' term | '!' term | '*' term  // no: &x
       | postfix

type : "int" | "char" // void is used only for function "result"

stars : [ '*' [ '*' ] ]

term : '(' type stars ')' term
     | '(' expr ')' call_or_index        // shortcut, since we know it's '('
     | unexpr

binop : '*' | '/' | '%'                  // prec. 12
      | '+' | '-'                        // prec. 11   10: << >>
      | '<' | '>' | '<''=' | '>''='      // prec. 9
      | '=''=' | '!''='                  // prec. 8
      | '&' | '^' | '|'                  // prec. 7 6 5
      | '&''&'                           // prec. 4
      | '|''|'                           // prec. 3    2: ?:
      | '='                              // prec. 1    also: += -= <<= ...

expr : term { binop term }

stmt : ';'
     | '{' { stmt } '}'
     | "break" ';'                | "return" [ expr ] ';'
     | "while" '(' expr ')' stmt  | "if" '(' expr ')' stmt [ "else" stmt ]
     | "for" '(' expr [ expr ] ';' [ expr { ',' expr } ] ')' stmt
     | expr // ends with ';'

arrayinit : @String                           // char a[] = "abc"; // ARRAY!
          | '{' @String { ',' @String } '}'   // char* b[] = {"ijk","mn"};
          | '{' integer { ',' integer } '}'   // int c[] = {1,2,3};

vartail : [ '=' expr ]
        | '[' ']' '=' arrayinit               // int** c[] = {0,0};
        | '[' integer ']' [ '=' arrayinit ]   // int d[100] = {0};

vars : vartail { ',' stars @Id vartail } ';'

vardef : type stars @Id vars   // type can't be void; ends with ';'

argdef : type stars @Id        // type can't be void; e.g. "char** argv"

args : argdef { ',' argdef }             // but can't be "char* argv[]"

fn_or_vars : '(' [ args ] ')' ';'   // TODO               // fn declaration
           | '(' [ args ] ')' '{' { vardef } { stmt } '}' // fn definition
           | vars                   // TODO

enumerator : @Id [ '=' integer ]

enumdef : '{' enumerator { ',' enumerator } '}' ';'

decl_or_def : "enum" enumdef
            | type stars @Id fn_or_vars     // TODO
            | "void" @Id fn_or_vars         // function-procedure

program : decl_or_def { decl_or_def } @Eof  // definition/declaration

# vim: set syntax=ANTLR :
